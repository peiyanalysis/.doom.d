<p><em>This article was discussed <a href="https://news.ycombinator.com/item?id=24007354">on Hacker News</a>.</em></p>

<p>A common situation in <a href="https://docs.python.org/3/library/asyncio.html">asyncio</a> Python programs is asynchronous
initialization. Some resource must be initialized exactly once before it
can be used, but the initialization itself is asynchronous — such as an
<a href="https://github.com/MagicStack/asyncpg">asyncpg</a> database. Let’s talk about a couple of solutions.</p>

<!--more-->

<p>The naive “solution” would be to track the initialization state in a
variable:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">initialized</span> <span class="o">=</span> <span class="bp">False</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">one_time_setup</span><span class="p">():</span>
    <span class="s">"Do not call more than once!"</span>
    <span class="p">...</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">maybe_initialize</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">initialized</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">initialized</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">one_time_setup</span><span class="p">()</span>
        <span class="n">initialized</span> <span class="o">=</span> <span class="bp">True</span>
</code></pre></div></div>

<p>The reasoning for <code class="language-plaintext highlighter-rouge">initialized</code> is the expectation of calling the
function more than once. However, if it might be called from concurrent
tasks there’s a <em>race condition</em>. If the second caller arrives while the
first is awaiting <code class="language-plaintext highlighter-rouge">one_time_setup()</code>, the function will be called a
second time.</p>

<p>Switching the order of the call and the assignment won’t help:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">def</span> <span class="nf">maybe_initialize</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">initialized</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">initialized</span><span class="p">:</span>
        <span class="n">initialized</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">await</span> <span class="n">one_time_setup</span><span class="p">()</span>
</code></pre></div></div>

<p>Since asyncio is cooperative, the first caller doesn’t give up control
until to other tasks until the <code class="language-plaintext highlighter-rouge">await</code>, meaning <code class="language-plaintext highlighter-rouge">one_time_setup()</code> will
never be called twice. However, the second caller may return before
<code class="language-plaintext highlighter-rouge">one_time_setup()</code> has completed. What we want is for <code class="language-plaintext highlighter-rouge">one_time_setup()</code>
to be called exactly once, but for no caller to return until it has
returned.</p>

<h3 id="mutual-exclusion">Mutual exclusion</h3>

<p>My first thought was to use a <a href="https://docs.python.org/3/library/asyncio-sync.html#lock">mutex lock</a>. This will protect the
variable <em>and</em> prevent followup callers from progressing too soon. Tasks
arriving while <code class="language-plaintext highlighter-rouge">one_time_setup()</code> is still running will block on the
lock.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">initialized</span> <span class="o">=</span> <span class="bp">False</span>
<span class="n">initialized_lock</span> <span class="o">=</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">Lock</span><span class="p">()</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">maybe_initialize</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">initialized</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">initialized_lock</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">initialized</span><span class="p">:</span>
            <span class="k">await</span> <span class="n">one_time_setup</span><span class="p">()</span>
            <span class="n">initialized</span> <span class="o">=</span> <span class="bp">True</span>
</code></pre></div></div>

<p>Unfortunately this has a serious downside: <strong>asyncio locks are
associated with the <a href="https://docs.python.org/3/library/asyncio-eventloop.html">loop</a> where they were created</strong>. Since the
lock variable is global, <code class="language-plaintext highlighter-rouge">maybe_initialize()</code> can only be called from
the same loop that loaded the module. <code class="language-plaintext highlighter-rouge">asyncio.run()</code> creates a new loop
so it’s incompatible.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># create a loop: always an error
</span><span class="n">asyncio</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">maybe_initialize</span><span class="p">())</span>

<span class="c1"># reuse the loop: maybe an error
</span><span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">get_event_loop</span><span class="p">()</span>
<span class="n">loop</span><span class="p">.</span><span class="n">run_until_complete</span><span class="p">((</span><span class="n">maybe_initialize</span><span class="p">()))</span>
</code></pre></div></div>

<p>(IMHO, it was a mistake for the asyncio API to include explicit loop
objects. It’s a low-level concept that unavoidably leaks through most
high-level abstractions.)</p>

<p>A workaround is to create the lock lazily. Thank goodness creating a
lock isn’t itself asynchronous!</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">initialized</span> <span class="o">=</span> <span class="bp">False</span>
<span class="n">initialized_lock</span> <span class="o">=</span> <span class="bp">None</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">maybe_initialize</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">initialized</span><span class="p">,</span> <span class="n">initialized_lock</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">initialized_lock</span><span class="p">:</span>
        <span class="n">initialized_lock</span> <span class="o">=</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">Lock</span><span class="p">()</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">initialized_lock</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">initialized</span><span class="p">:</span>
            <span class="k">await</span> <span class="n">one_time_setup</span><span class="p">()</span>
            <span class="n">initialized</span> <span class="o">=</span> <span class="bp">True</span>
</code></pre></div></div>

<p>This is better, but <code class="language-plaintext highlighter-rouge">maybe_initialize()</code> can still only ever be called
from a single loop.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">asyncio</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">maybe_initialize</span><span class="p">())</span> <span class="c1"># ok
</span><span class="n">asyncio</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">maybe_initialize</span><span class="p">())</span> <span class="c1"># error!
</span></code></pre></div></div>

<h3 id="once">Once</h3>

<p>The pthreads API provides <a href="https://pubs.opengroup.org/onlinepubs/007908799/xsh/pthread_once.html"><code class="language-plaintext highlighter-rouge">pthread_once</code></a> to solve this problem.
C++11 has similarly has <a href="https://en.cppreference.com/w/cpp/thread/call_once"><code class="language-plaintext highlighter-rouge">std::call_once</code></a>. We can build something
similar using a future-like object.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">future</span> <span class="o">=</span> <span class="bp">None</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">maybe_initialize</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">future</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">future</span><span class="p">:</span>
        <span class="n">future</span> <span class="o">=</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">one_time_setup</span><span class="p">())</span>
    <span class="k">await</span> <span class="n">future</span>
</code></pre></div></div>

<p>Awaiting a coroutine more than once is an error, but <a href="https://docs.python.org/3/library/asyncio-task.html#task-object">tasks</a> are
future-like objects and can be awaited more than once. At least on
CPython, they can also be awaited in other loops! So not only is this
simpler, it also solves the loop problem!</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">asyncio</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">maybe_initialize</span><span class="p">())</span> <span class="c1"># ok
</span><span class="n">asyncio</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">maybe_initialize</span><span class="p">())</span> <span class="c1"># still ok
</span></code></pre></div></div>

<p>This can be tidied up nicely in a <code class="language-plaintext highlighter-rouge">@once</code> decorator:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">once</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="n">future</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">once_wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">nonlocal</span> <span class="n">future</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">future</span><span class="p">:</span>
            <span class="n">future</span> <span class="o">=</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
        <span class="k">return</span> <span class="k">await</span> <span class="n">future</span>
    <span class="k">return</span> <span class="n">once_wrapper</span>
</code></pre></div></div>

<p>No more need for <code class="language-plaintext highlighter-rouge">maybe_initialize()</code>, just decorate the original
<code class="language-plaintext highlighter-rouge">one_time_setup()</code>:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">once</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">one_time_setup</span><span class="p">():</span>
    <span class="p">...</span>
</code></pre></div></div>


    