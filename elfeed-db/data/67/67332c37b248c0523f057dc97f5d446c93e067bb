<p>Python <a href="https://docs.python.org/3/library/asyncio.html">asyncio</a> has support for asynchronous networking,
subprocesses, and interprocess communication. However, it has nothing
for asynchronous file operations — opening, reading, writing, or
closing. This is likely in part because operating systems themselves
also lack these facilities. If a file operation takes a long time,
perhaps because the file is on a network mount, then the entire Python
process will hang. It’s possible to work around this, so let’s build a
utility that can asynchronously open and close files.</p>

<p>The usual way to work around the lack of operating system support for a
particular asynchronous operation is to <a href="http://docs.libuv.org/en/v1.x/design.html#file-i-o">dedicate threads to waiting on
those operations</a>. By using a thread pool, we can even avoid the
overhead of spawning threads when we need them. Plus asyncio is designed
to play nicely with thread pools anyway.</p>

<h3 id="test-setup">Test setup</h3>

<p>Before we get started, we’ll need some way to test that it’s working. We
need a slow file system. One thought is to <a href="/blog/2018/06/23/">use ptrace to intercept the
relevant system calls</a>, though this isn’t quite so simple. The
other threads need to continue running while the thread waiting on
<code class="language-plaintext highlighter-rouge">open(2)</code> is paused, but ptrace pauses the whole process. Fortunately
there’s a simpler solution anyway: <code class="language-plaintext highlighter-rouge">LD_PRELOAD</code>.</p>

<p>Setting the <code class="language-plaintext highlighter-rouge">LD_PRELOAD</code> environment variable to the name of a shared
object will cause the loader to load this shared object ahead of
everything else, allowing that shared object to override other
libraries. I’m on x86-64 Linux (Debian), and so I’m looking to override
<code class="language-plaintext highlighter-rouge">open64(2)</code> in glibc. Here’s my <code class="language-plaintext highlighter-rouge">open64.c</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define _GNU_SOURCE
#include &lt;dlfcn.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
</span>
<span class="kt">int</span>
<span class="nf">open64</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">"/tmp/"</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="n">dlsym</span><span class="p">(</span><span class="n">RTLD_NEXT</span><span class="p">,</span> <span class="s">"open64"</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now Python must go through my C function when it opens files. If the
file resides where under <code class="language-plaintext highlighter-rouge">/tmp/</code>, opening the file will be delayed by 3
seconds. Since I still want to actually open a file, I use <code class="language-plaintext highlighter-rouge">dlsym()</code> to
access the <em>real</em> <code class="language-plaintext highlighter-rouge">open64()</code> in glibc. I build it like so:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cc -shared -fPIC -o open64.so open64.c -ldl
</code></pre></div></div>

<p>And to test that it works with Python, let’s time how long it takes to
open <code class="language-plaintext highlighter-rouge">/tmp/x</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ touch /tmp/x
$ time LD_PRELOAD=./open64.so python3 -c 'open("/tmp/x")'

real    0m3.021s
user    0m0.014s
sys     0m0.005s
</code></pre></div></div>

<p>Perfect! (Note: It’s a little strange putting <code class="language-plaintext highlighter-rouge">time</code> <em>before</em> setting the
environment variable, but that’s because I’m using Bash and it <code class="language-plaintext highlighter-rouge">time</code> is
special since this is the shell’s version of the command.)</p>

<h3 id="thread-pools">Thread pools</h3>

<p>Python’s standard <code class="language-plaintext highlighter-rouge">open()</code> is most commonly used as a <em>context manager</em>
so that the file is automatically closed no matter what happens.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'output.txt'</span><span class="p">,</span> <span class="s">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">out</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'hello world'</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
</code></pre></div></div>

<p>I’d like my asynchronous open to follow this pattern using <a href="https://www.python.org/dev/peps/pep-0492/"><code class="language-plaintext highlighter-rouge">async
with</code></a>. It’s like <code class="language-plaintext highlighter-rouge">with</code>, but the context manager is acquired and
released asynchronously. I’ll call my version <code class="language-plaintext highlighter-rouge">aopen()</code>:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">with</span> <span class="n">aopen</span><span class="p">(</span><span class="s">'output.txt'</span><span class="p">,</span> <span class="s">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">out</span><span class="p">:</span>
    <span class="p">...</span>
</code></pre></div></div>

<p>So <code class="language-plaintext highlighter-rouge">aopen()</code> will need to return an <em>asynchronous context manager</em>, an
object with methods <code class="language-plaintext highlighter-rouge">__aenter__</code> and <code class="language-plaintext highlighter-rouge">__aexit__</code> that both return
<a href="https://docs.python.org/3/glossary.html#term-awaitable"><em>awaitables</em></a>. Usually this is by virtue of these methods being
<a href="https://docs.python.org/3/glossary.html#term-coroutine-function"><em>coroutine functions</em></a>, but a normal function that directly returns
an awaitable also works, which is what I’ll be doing for <code class="language-plaintext highlighter-rouge">__aenter__</code>.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">_AsyncOpen</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="p">...</span>

    <span class="k">def</span> <span class="nf">__aenter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="p">...</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">__aexit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="p">...</span>
</code></pre></div></div>

<p>Ultimately we have to call <code class="language-plaintext highlighter-rouge">open()</code>. The arguments for <code class="language-plaintext highlighter-rouge">open()</code> will be
given to the constructor to be used later. This will make more sense
when you see the definition for <code class="language-plaintext highlighter-rouge">aopen()</code>.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>
</code></pre></div></div>

<p>When it’s time to actually open the file, Python will call <code class="language-plaintext highlighter-rouge">__aenter__</code>.
We can’t call <code class="language-plaintext highlighter-rouge">open()</code> directly since that will block, so we’ll use a
thread pool to wait on it. Rather than create a thread pool, we’ll use
the one that comes with the current event loop. The <code class="language-plaintext highlighter-rouge">run_in_executor()</code>
method runs a function in a thread pool — where <code class="language-plaintext highlighter-rouge">None</code> means use the
default pool — returning an asyncio future representing the future
result, in this case the opened file object.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">def</span> <span class="nf">__aenter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">thread_open</span><span class="p">():</span>
            <span class="k">return</span> <span class="nb">open</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">_args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="p">.</span><span class="n">_kwargs</span><span class="p">)</span>
        <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">get_event_loop</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_future</span> <span class="o">=</span> <span class="n">loop</span><span class="p">.</span><span class="n">run_in_executor</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">thread_open</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_future</span>
</code></pre></div></div>

<p>Since this <code class="language-plaintext highlighter-rouge">__aenter__</code> is not a coroutine function, it returns the
future directly as its awaitable result. The caller will await it.</p>

<p>The default thread pool is limited to one thread per core, which I
suppose is the most obvious choice, though not ideal here. That’s fine
for CPU-bound operations but not for I/O-bound operations. In a real
program we may want to use a larger thread pool.</p>

<p>Closing a file may block, so we’ll do that in a thread pool as well.
First pull the file object <a href="/blog/2020/07/30/">from the future</a>, then close it in the
thread pool, waiting until the file has actually closed:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">async</span> <span class="k">def</span> <span class="nf">__aexit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="nb">file</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">_future</span>
        <span class="k">def</span> <span class="nf">thread_close</span><span class="p">():</span>
            <span class="nb">file</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">get_event_loop</span><span class="p">()</span>
        <span class="k">await</span> <span class="n">loop</span><span class="p">.</span><span class="n">run_in_executor</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">thread_close</span><span class="p">)</span>
</code></pre></div></div>

<p>The open and close are paired in this context manager, but it may be
concurrent with an arbitrary number of other <code class="language-plaintext highlighter-rouge">_AsyncOpen</code> context
managers. There will be some upper limit to the number of open files, so
<strong>we need to be careful not to use too many of these things
concurrently</strong>, something <a href="/blog/2020/05/24/">which easily happens when using unbounded
queues</a>. Lacking back pressure, all it takes is for tasks to be
opening files slightly faster than they close them.</p>

<p>With all the hard work done, the definition for <code class="language-plaintext highlighter-rouge">aopen()</code> is trivial:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">aopen</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_AsyncOpen</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
</code></pre></div></div>

<p>That’s it! Let’s try it out with the <code class="language-plaintext highlighter-rouge">LD_PRELOAD</code> test.</p>

<h3 id="a-test-drive">A test drive</h3>

<p>First define a “heartbeat” task that will tell us the asyncio loop is
still chugging away while we wait on opening the file.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">def</span> <span class="nf">heartbeat</span><span class="p">():</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'HEARTBEAT'</span><span class="p">)</span>
</code></pre></div></div>

<p>Here’s a test function for <code class="language-plaintext highlighter-rouge">aopen()</code> that asynchronously opens a file
under <code class="language-plaintext highlighter-rouge">/tmp/</code> named by an integer, (synchronously) writes that integer
to the file, then asynchronously closes it.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">aopen</span><span class="p">(</span><span class="s">f'/tmp/</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s">'</span><span class="p">,</span> <span class="s">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">out</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">main()</code> function creates the heartbeat task and opens 4 files
concurrently though the intercepted file opening routine:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">beat</span> <span class="o">=</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">heartbeat</span><span class="p">())</span>
    <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">asyncio</span><span class="p">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">tasks</span><span class="p">)</span>
    <span class="n">beat</span><span class="p">.</span><span class="n">cancel</span><span class="p">()</span>

<span class="n">asyncio</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</code></pre></div></div>

<p>The result:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ LD_PRELOAD=./open64.so python3 aopen.py
HEARTBEAT
HEARTBEAT
HEARTBEAT
HEARTBEAT
HEARTBEAT
HEARTBEAT
$ cat /tmp/{1,2,3,4}
1
2
3
4
</code></pre></div></div>

<p>As expected, 6 heartbeats corresponding to 3 seconds that all 4 tasks
spent concurrently waiting on the intercepted <code class="language-plaintext highlighter-rouge">open()</code>. Here’s the full
source if you want to try it our for yourself:</p>

<p><a href="https://gist.github.com/skeeto/89af673a0a0d24de32ad19ee505c8dbd">https://gist.github.com/skeeto/89af673a0a0d24de32ad19ee505c8dbd</a></p>

<h3 id="caveat-no-asynchronous-reads-and-writes">Caveat: no asynchronous reads and writes</h3>

<p><em>Only</em> opening and closing the file is asynchronous. Read and writes are
unchanged, still fully synchronous and blocking, so this is only a half
solution. A full solution is not nearly as simple because asyncio is
async/await. Asynchronous reads and writes would require all new APIs
<a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">with different coloring</a>. You’d need an <code class="language-plaintext highlighter-rouge">aprint()</code> to complement
<code class="language-plaintext highlighter-rouge">print()</code>, and so on, each returning an <code class="language-plaintext highlighter-rouge">awaitable</code> to be awaited.</p>

<p>This is one of the unfortunate downsides of async/await. I strongly
prefer conventional, preemptive concurrency, <em>but</em> we don’t always have
that luxury.</p>


    