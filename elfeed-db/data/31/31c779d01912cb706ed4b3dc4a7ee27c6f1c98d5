<p><em>This article was discussed <a href="https://news.ycombinator.com/item?id=25120083">on Hacker News</a>.</em></p>

<p><a href="https://www.pixelships.com/">Pixelmusement</a> produces videos about <a href="/blog/2020/10/19/">MS-DOS games</a> and software.
Each video ends with a short, randomly-selected listing of financial
backers. In <a href="https://www.youtube.com/watch?v=YVV9bkbpaPY">ADG Filler #57</a>, Kris revealed the selection process,
and it absolutely fits the channel’s core theme: a <a href="https://en.wikipedia.org/wiki/QBasic">QBasic</a> program.
His program relies on QBasic’s built-in pseudo random number generator
(PRNG). Even accounting for the platform’s limitations, the PRNG is much
poorer quality than it could be. Let’s discuss these weaknesses and figure
out how to make the selection more fair.</p>

<!--more-->

<p>Kris’s program seeds the PRNG with the system clock (<code class="language-plaintext highlighter-rouge">RANDOMIZE TIMER</code>, a
QBasic idiom), populates an array with the backers represented as integers
(indices), continuously shuffles the list until the user presses a key, then
finally prints out a random selection from the array. Here’s a simplified
version of the program (note: QBasic comments start with apostrophe <code class="language-plaintext highlighter-rouge">'</code>):</p>

<pre><code class="language-qbasic">CONST ntickets = 203  ' input parameter
CONST nresults = 12

RANDOMIZE TIMER

DIM tickets(0 TO ntickets - 1) AS LONG
FOR i = 0 TO ntickets - 1
    tickets(i) = i
NEXT

CLS
PRINT "Press any key to stop shuffling..."
DO
    i = INT(RND * ntickets)
    j = INT(RND * ntickets)
    SWAP tickets(i), tickets(j)
LOOP WHILE INKEY$ = ""

FOR i = 0 to nresults - 1
    PRINT tickets(i)
NEXT
</code></pre>

<p>This should be readable even if you don’t know QBasic. Note: In the real
program, backers at higher tiers get multiple tickets in order to weight
the results. This is accounted for in the final loop such that nobody
appears more than once. It’s mostly irrelevant to the discussion here, so
I’ve omitted it.</p>

<p>The final result is ultimately a function of just three inputs:</p>

<ol>
  <li>The system clock (<code class="language-plaintext highlighter-rouge">TIMER</code>)</li>
  <li>The total number of tickets</li>
  <li>The number of loop iterations until a key press</li>
</ol>

<p>The second item has the nice property that by becoming a backer you influence
the result.</p>

<h3 id="qbasic-rnd">QBasic RND</h3>

<p>QBasic’s PRNG is this 24-bit <a href="https://en.wikipedia.org/wiki/Linear_congruential_generator">Linear Congruential Generator</a> (LCG):</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint32_t</span>
<span class="nf">rnd24</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="mh">0xfd43fd</span> <span class="o">+</span> <span class="mh">0xc39ec3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffff</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The result is the entire 24-bit state. <code class="language-plaintext highlighter-rouge">RND</code> divides this by 2^24 and
returns it as a single precision float so that the caller receives a value
between 0 and 1 (exclusive).</p>

<p>Needless to say, this is a very poor PRNG. The <a href="/blog/2019/11/19/">LCG constants are
<em>reasonable</em></a>, but the choice to limit the state to 24 bits is
strange. According to the <a href="https://www.qb64.org/forum/index.php?topic=1414.0">QBasic 16-bit assembly</a> (note: the LCG
constants listed here <a href="http://www.qb64.net/forum/index_topic_10727-0/">are wrong</a>), the implementation is a full
32-bit multiply using 16-bit limbs, and it allocates and writes a full 32
bits when storing the state. As expected for the 8086, there was nothing
gained by using only the lower 24 bits.</p>

<p>To illustrate how poor it is, here’s a <a href="https://www.pcg-random.org/posts/visualizing-the-heart-of-some-prngs.html">randogram</a> for this PRNG,
which shows obvious structure. (This is a small slice of a 4096x4096
randogram where each of the 2^23 24-bit samples is plotted as two 12-bit
coordinates.)</p>

<p><img src="/img/qbasic/rnd-thumb.png" alt="" /></p>

<p>Admittedly this far <a href="https://www.pcg-random.org/paper.html"><em>overtaxes</em></a> the PRNG. With a 24-bit state, it’s
only good for 4,096 (2^12) outputs, after which it no longer follows the
<a href="/blog/2019/07/22/">birthday paradox</a>: No outputs are repeated even though we should
start seeing some. However, as I’ll soon show, this doesn’t actually
matter.</p>

<p>Instead of discarding the high 8 bits — the highest quality output bits —
QBasic’s designers should have discarded the <em>low</em> 8 bits for the output,
turning it into a <em>truncated 32-bit LCG</em>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint32_t</span>
<span class="nf">rnd32</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="mh">0xfd43fd</span> <span class="o">+</span> <span class="mh">0xc39ec3</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">s</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This LCG would have the same performance, but significantly better
quality. Here’s the randogram for this PRNG, and it is <em>also</em> heavily
overtaxed (more than 65,536, 2^16 outputs).</p>

<p><img src="/img/qbasic/rnd32-thumb.png" alt="" /></p>

<p>It’s a solid upgrade, <em>completely for free</em>!</p>

<h3 id="qbasic-randomize">QBasic RANDOMIZE</h3>

<p>That’s not the end of our troubles. The <code class="language-plaintext highlighter-rouge">RANDOMIZE</code> statement accepts a
double precision (i.e. 64-bit) seed. The high 16 bits of its IEEE 754
binary representation are XORed with the next highest 16 bits. The high 16
bits of the PRNG state is set to this result. The lowest 8 bits are
preserved.</p>

<p>To make this clearer, here’s a C implementation, verified against QBasic
7.1:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint32_t</span> <span class="n">s</span><span class="p">;</span>

<span class="kt">void</span>
<span class="nf">randomize</span><span class="p">(</span><span class="kt">double</span> <span class="n">seed</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span> <span class="p">,</span><span class="o">&amp;</span><span class="n">seed</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
    <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">&gt;&gt;</span><span class="mi">24</span> <span class="o">^</span> <span class="n">x</span><span class="o">&gt;&gt;</span><span class="mi">40</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff00</span> <span class="o">|</span> <span class="p">(</span><span class="n">s</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In other words, <strong><code class="language-plaintext highlighter-rouge">RANDOMIZE</code> only sets the PRNG to one of 65,536 possible
states</strong>.</p>

<p>As the final piece, here’s how <code class="language-plaintext highlighter-rouge">RND</code> is implemented, also verified against
QBasic 7.1:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span>
<span class="nf">rnd</span><span class="p">(</span><span class="kt">float</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">arg</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span> <span class="o">&amp;</span> <span class="mh">0xffffff</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">s</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">arg</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">*</span><span class="mh">0xfd43fd</span> <span class="o">+</span> <span class="mh">0xc39ec3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffff</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">s</span> <span class="o">/</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="mh">0x1000000</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="system-clock-seed">System clock seed</h3>

<p>The <a href="https://www.qb64.org/wiki/TIMER"><code class="language-plaintext highlighter-rouge">TIMER</code> function</a> returns the single precision number of
seconds since midnight with ~55ms precision (i.e. the 18.2Hz timer
interrupt counter). This is strictly time of day, and the current date is
not part of the result, unlike, say, the unix epoch.</p>

<p>This means there are only 1,572,480 distinct values returned by <code class="language-plaintext highlighter-rouge">TIMER</code>.
That’s small even before considering that these map onto only 65,536
possible seeds with <code class="language-plaintext highlighter-rouge">RANDOMIZE</code> — all of which <em>are</em> fortunately
realizable via <code class="language-plaintext highlighter-rouge">TIMER</code>.</p>

<p>Of the three inputs to random selection, this first one is looking pretty
bad.</p>

<h3 id="loop-iterations">Loop iterations</h3>

<p>Kris’s idea of continuously mixing the array until he presses a key makes
up for much of the QBasic PRNG weaknesses. He lets it run for over 200,000
array swaps — traversing over 2% of the PRNG’s period — and the array
itself acts like an extended PRNG state, supplementing the 24-bit <code class="language-plaintext highlighter-rouge">RND</code>
state.</p>

<p>Since iterations fly by quickly, the exact number of iterations becomes
another <a href="/blog/2019/04/30/">source of entropy</a>. The results will be quite different if it
runs 214,600 iterations versus 273,500 iterations.</p>

<p>Possible improvement: Only exit the loop when a certain key is pressed. If
any other key is pressed then that input and the <code class="language-plaintext highlighter-rouge">TIMER</code> are mixed into
the PRNG state. Mashing the keyboard during the loop introduces more
entropy.</p>

<h3 id="replacing-the-prng">Replacing the PRNG</h3>

<p>Since the built-in PRNG is so poor, we could improve the situation by
implementing a <a href="/blog/2017/09/21/">new one</a> in QBasic itself. The challenge is that
QBasic has no unsigned integers, not even unsigned integer operators (i.e.
Java and JavaScript’s <code class="language-plaintext highlighter-rouge">&gt;&gt;&gt;</code>), and signed overflow is a run-time error. We
can’t even re-implement QBasic’s own LCG without doing long multiplication
in software, since the intermediate result overflows its 32-bit <code class="language-plaintext highlighter-rouge">LONG</code>.</p>

<p>Popular choices in these constraints are <a href="https://en.wikipedia.org/wiki/Lehmer_random_number_generator">Park–Miller generator</a> (as
we saw <a href="/blog/2018/12/25/">in Bash</a>) or a <a href="https://en.wikipedia.org/wiki/Lagged_Fibonacci_generator">lagged Fibonacci generator</a> (as used by
Emacs, which was for a long time constrained to 29-bit integers).</p>

<p>However, I have a better idea: a PRNG based on <a href="https://en.wikipedia.org/wiki/RC4">RC4</a>. Specifically,
my own design called <a href="https://gist.github.com/skeeto/f872ec5672f7fc90c6085ecbaa16b2f3"><strong>Sponge4</strong></a>, a <a href="https://en.wikipedia.org/wiki/Sponge_function">sponge construction</a>
built atop RC4. In short: Mixing in more input is just a matter of running
the key schedule again. Implementing this PRNG requires just two simple
operations: modular addition over 2^8, and array swap. QBasic has a <code class="language-plaintext highlighter-rouge">SWAP</code>
statement, so it’s a natural fit!</p>

<p>Sponge4 (RC4) has much higher quality output than the 24-bit LCG, and I
can mix in more sources of entropy. With its 1,700-bit state, it can
absorb quite a bit of entropy without loss.</p>

<h4 id="learning-qbasic">Learning QBasic</h4>

<p>Until this past weekend, I had not touched QBasic for about 23 years and
had to learn it essentially from scratch. Though within a couple of hours
I probably already understood it better than I ever had. That’s in large
part because I’m far more experienced, but also probably because QBasic
tutorials are universally awful. Not surprisingly they’re written for
beginners, but they also seem to be all written <em>by</em> beginners, too. I
soon got the impression that QBasic community has usually been another
case of <a href="/blog/2019/09/25/">the blind leading the blind</a>.</p>

<p>There’s little direct information for experienced programmers, and even
the official documentation tends to be thin in important places. I wanted
documentation that started with the core language semantics:</p>

<ul>
  <li>
    <p>The basic types are INTEGER (int16), LONG (int32), SINGLE (float32),
DOUBLE (float64), and two flavors of STRING, fixed-width and
variable-width. Late versions also had incomplete support for a 64-bit,
10,000x fixed-point CURRENCY type.</p>
  </li>
  <li>
    <p>Variables are SINGLE by default and do not need to be declared ahead of
time. Arrays have 11 elements by default.</p>
  </li>
  <li>
    <p>Variables, constants, and functions may have a suffix if their type is
not SINGLE: INTEGER <code class="language-plaintext highlighter-rouge">%</code>, LONG <code class="language-plaintext highlighter-rouge">&amp;</code>, SINGLE <code class="language-plaintext highlighter-rouge">!</code>, DOUBLE <code class="language-plaintext highlighter-rouge">#</code>, STRING <code class="language-plaintext highlighter-rouge">$</code>,
and CURRENCY <code class="language-plaintext highlighter-rouge">@</code>. For functions, this is the return type.</p>
  </li>
  <li>
    <p>Each variable type has its own namespace, i.e. <code class="language-plaintext highlighter-rouge">i%</code> is distinct from
<code class="language-plaintext highlighter-rouge">i&amp;</code>. Arrays are also their own namespace, i.e. <code class="language-plaintext highlighter-rouge">i%</code> is distinct from
<code class="language-plaintext highlighter-rouge">i%(0)</code> is distinct from <code class="language-plaintext highlighter-rouge">i&amp;(0)</code>.</p>
  </li>
  <li>
    <p>Variables may be declared explicitly with <code class="language-plaintext highlighter-rouge">DIM</code>. Declaring a variable
with <code class="language-plaintext highlighter-rouge">DIM</code> allows the suffix to be omitted. It also locks that name out
of the other type namespaces, i.e. <code class="language-plaintext highlighter-rouge">DIM i AS LONG</code> makes any use of <code class="language-plaintext highlighter-rouge">i%</code>
invalid in that scope. Though arrays and scalars can still have the same
name even with <code class="language-plaintext highlighter-rouge">DIM</code> declarations.</p>
  </li>
  <li>
    <p>Numeric operations with mixed types implicitly promote like C.</p>
  </li>
  <li>
    <p>Functions and subroutines have a single, common namespace regardless of
function suffix. As a result, the suffix can (usually) be omitted at
function call sites. Built-in functions are special in this case.</p>
  </li>
  <li>
    <p>Despite initial appearances, QBasic is statically-typed.</p>
  </li>
  <li>
    <p>The default is pass-by-reference. Use <code class="language-plaintext highlighter-rouge">BYVAL</code> to pass by value.</p>
  </li>
  <li>
    <p>In array declarations, the parameter is not the <em>size</em> but the largest
index. Multidimensional arrays are supported. Arrays need not be indexed
starting at zero (e.g. <code class="language-plaintext highlighter-rouge">(x TO y)</code>), though this is the default.</p>
  </li>
  <li>
    <p>Strings are not arrays, but their own special thing with special
accessor statements and functions.</p>
  </li>
  <li>
    <p>Scopes are module, subroutine, and function. “Global” variables must be
declared with <code class="language-plaintext highlighter-rouge">SHARED</code>.</p>
  </li>
  <li>
    <p>Users can define custom structures with <code class="language-plaintext highlighter-rouge">TYPE</code>. Functions cannot return
user-defined types and instead rely on pass-by-reference.</p>
  </li>
  <li>
    <p>A crude kind of dynamic allocation is supported with <code class="language-plaintext highlighter-rouge">REDIM</code> to resize
<code class="language-plaintext highlighter-rouge">$DYNAMIC</code> arrays at run-time. <code class="language-plaintext highlighter-rouge">ERASE</code> frees allocations.</p>
  </li>
</ul>

<p><em>These</em> are the semantics I wanted to know getting started. Throw in some
illustrative examples, and then it’s a tutorial for experienced
developers. (Future article perhaps?) Anyway, that’s enough to follow
along below.</p>

<h4 id="implementing-sponge4">Implementing Sponge4</h4>

<p>Like RC4, I need a 256-element byte array, and two 1-byte indices, <code class="language-plaintext highlighter-rouge">i</code> and
<code class="language-plaintext highlighter-rouge">j</code>. Sponge4 also keeps a third 1-byte counter, <code class="language-plaintext highlighter-rouge">k</code>, to count input.</p>

<pre><code class="language-qbasic">TYPE sponge4
    i AS INTEGER
    j AS INTEGER
    k AS INTEGER
    s(0 TO 255) AS INTEGER
END TYPE
</code></pre>

<p>QBasic doesn’t have a “byte” type. A fixed-size 256-byte string would
normally be a good match here, but since they’re not arrays, strings are
not compatible with <code class="language-plaintext highlighter-rouge">SWAP</code> and are not indexed efficiently. So instead I
accept some wasted space and use 16-bit integers for everything.</p>

<p>There are four “methods” for this structure. Three are subroutines since
they don’t return a value, but mutate the sponge. The last, <code class="language-plaintext highlighter-rouge">squeeze</code>,
returns the next byte as an INTEGER (<code class="language-plaintext highlighter-rouge">%</code>).</p>

<pre><code class="language-qbasic">DECLARE SUB init (r AS sponge4)
DECLARE SUB absorb (r AS sponge4, b AS INTEGER)
DECLARE SUB absorbstop (r AS sponge4)
DECLARE FUNCTION squeeze% (r AS sponge4)
</code></pre>

<p>Initialization follows RC4:</p>

<pre><code class="language-qbasic">SUB init (r AS sponge4)
    r.i = 0
    r.j = 0
    r.k = 0
    FOR i% = 0 TO 255
        r.s(i%) = i%
    NEXT
END SUB
</code></pre>

<p>Absorbing a byte means running the RC4 key schedule one step. Absorbing a
“stop” symbol, for separating inputs, transforms the state in a way that
absorbing a byte cannot.</p>

<pre><code class="language-qbasic">SUB absorb (r AS sponge4, b AS INTEGER)
    r.j = (r.j + r.s(r.i) + b) MOD 256
    SWAP r.s(r.i), r.s(r.j)
    r.i = (r.i + 1) MOD 256
    r.k = (r.k + 1) MOD 256
END SUB

SUB absorbstop (r AS sponge4)
    r.j = (r.j + 1) MOD 256
END SUB
</code></pre>

<p>Squeezing a byte may involve mixing the state first, then it runs the RC4
generator normally.</p>

<pre><code class="language-qbasic">FUNCTION squeeze% (r AS sponge4)
    IF r.k &gt; 0 THEN
        absorbstop r
        DO WHILE r.k &gt; 0
            absorb r, r.k
        LOOP
    END IF

    r.j = (r.j + r.i) MOD 256
    r.i = (r.i + 1) MOD 256
    SWAP r.s(r.i), r.s(r.j)
    squeeze% = r.s((r.s(r.i) + r.s(r.j)) MOD 256)
END FUNCTION
</code></pre>

<p>That’s the entire generator in QBasic! A couple more helper functions will
be useful, though. One absorbs entire strings, and the second emits 24-bit
results.</p>

<pre><code class="language-qbasic">SUB absorbstr (r AS sponge4, s AS STRING)
    FOR i% = 1 TO LEN(s)
        absorb r, ASC(MID$(s, i%))
    NEXT
END SUB

FUNCTION squeeze24&amp; (r AS sponge4)
    b0&amp; = squeeze%(r)
    b1&amp; = squeeze%(r)
    b2&amp; = squeeze%(r)
    squeeze24&amp; = b2&amp; * &amp;H10000 + b1&amp; * &amp;H100 + b0&amp;
END FUNCTION
</code></pre>

<p>QBasic doesn’t have bit-shift operations, so we must make due with
multiplication. The <code class="language-plaintext highlighter-rouge">&amp;H</code> is hexadecimal notation.</p>

<h4 id="putting-the-sponge-to-use">Putting the sponge to use</h4>

<p>One of the problems with the original program is that only the time of day
was a seed. Even were it mixed better, if we run the program at exactly
the same instant on two different days, we get the same seed. The <code class="language-plaintext highlighter-rouge">DATE$</code>
function returns the current date, which we can absorb into the sponge to
make the whole date part of the input.</p>

<pre><code class="language-qbasic">DIM sponge AS sponge4
init sponge
absorbstr sponge, DATE$
absorbstr sponge, MKS$(TIMER)
absorbstr sponge, MKI$(ntickets)
</code></pre>

<p>I follow this up with the timer. It’s converted to a string with <code class="language-plaintext highlighter-rouge">MKS$</code>,
which returns the little-endian, single precision binary representation as
a 4-byte string. <code class="language-plaintext highlighter-rouge">MKI$</code> does the same for INTEGER, as a 2-byte string.</p>

<p>One of the problems with the original program was bias: Multiplying <code class="language-plaintext highlighter-rouge">RND</code>
by a constant, then truncating the result to an integer is not uniform in
most cases. Some numbers are selected slightly more often than others
because 2^24 inputs cannot map uniformly onto, say, 10 outputs. With all
the shuffling in the original it probably doesn’t make a practical
difference, but I’d like to avoid it.</p>

<p>In my program I account for it by generating another number if it happens
to fall into that extra “tail” part of the input distribution (very
unlikely for small <code class="language-plaintext highlighter-rouge">ntickets</code>). The <code class="language-plaintext highlighter-rouge">squeezen</code> function uniformly
generates a number in 0 to N (exclusive).</p>

<pre><code class="language-qbasic">FUNCTION squeezen% (r AS sponge4, n AS INTEGER)
    DO
       x&amp; = squeeze24&amp;(r) - &amp;H1000000 MOD n
    LOOP WHILE x&amp; &lt; 0
    squeezen% = x&amp; MOD n
END FUNCTION
</code></pre>

<p>Finally a Fisher–Yates shuffle, then print the first N elements:</p>

<pre><code class="language-qbasic">FOR i% = ntickets - 1 TO 1 STEP -1
    j% = squeezen%(sponge, i% + 1)
    SWAP tickets(i%), tickets(j%)
NEXT

FOR i% = 1 TO nresults
    PRINT tickets(i%)
NEXT
</code></pre>

<p>Though if you really love Kris’s loop idea:</p>

<pre><code class="language-qbasic">PRINT "Press Esc to finish, any other key for entropy..."
DO
    c&amp; = c&amp; + 1
    LOCATE 2, 1
    PRINT "cycles ="; c&amp;; "; keys ="; k%

    FOR i% = ntickets - 1 TO 1 STEP -1
        j% = squeezen%(sponge, i% + 1)
        SWAP tickets(i%), tickets(j%)
    NEXT

    k$ = INKEY$
    IF k$ = CHR$(27) THEN
        EXIT DO
    ELSEIF k$ &lt;&gt; "" THEN
        k% = k% + 1
        absorbstr sponge, k$
    END IF
    absorbstr sponge, MKS$(TIMER)
LOOP
</code></pre>

<p>If you want to try it out for yourself in, say, DOSBox, here’s the full
source: <a href="https://gist.github.com/skeeto/17cb335d9652b2fc6f11485393362543"><strong><code class="language-plaintext highlighter-rouge">sponge4.bas</code></strong></a></p>


    