<ol>
<li><p>
Describe what happens when the following expressions are evaluated:
</p>

<pre>
(a) (+ (- 5 1) (+ 3 7))
(b) (list 1 (+ 2 3))
(c) (if (listp 1) (+ 1 2) (+ 3 4))
(d) (list (and (listp 3) t) (+ 1 2))
</pre>

<p>
My answer:
</p>

<p>
(a) 14
</p>

<p>
(b) (1 5)
</p>

<p>
(c) 7
</p>

<p>
(d) (NIL 3)
</p></li>

<li><p>
Give three distinct cons expressions that return (a b c).
</p>

<p>
My answer:
</p>
<div>

<pre>(cons 'a '(b c))
(cons 'a (cons 'b '(c)))
(cons 'a (cons 'b (cons 'c nil)))
</pre>
</div></li>

<li><p>
Using <b>car</b> and <b>cdr</b>,define a function to return the fourth element of a list.
</p>

<p>
My answer:
</p>
<div>

<pre>(<span>defun</span> <span>fourth</span> (lst)
  (<span>if</span> (listp lst)
    (car (cdr (cdr (cdr lst))))))
</pre>
</div></li>

<li><p>
Define a function that takes two arguments and returns the greater of the two.
</p>

<p>
My answer:
</p>
<div>

<pre>(<span>defun</span> <span>greater</span> (a b)
  (<span>if</span> (equal (type-of a)
             (type-of b))
      (<span>cond</span> ((typep a 'number) (<span>if</span> (&gt; a b) a b)
            ((typep a 'character) (<span>if</span> (char&gt; a b) a b))
            ((typep a 'string) (<span>if</span> (string&gt; a b) a b))
            (t nil)))
      nil))
</pre>
</div></li>

<li><p>
What do hese functions do?
</p>

<p>
(a)
</p>
<div>

<pre>(<span>defun</span> <span>enigma</span> (x)
  (and (not (null x))
       (or  (null (car x))
            (enigma (cdr x)))))
</pre>
</div>

<p>
(b)
</p>
<div>

<pre>(<span>defun</span> <span>mystery</span> (x y)
  (<span>if</span> (null y)
      nil
      (<span>if</span> (eql (car y) x)
          0
          (<span>let</span> ((z (mystery x (cdr y))))
            (and z (+ z 1))))))
</pre>
</div>

<p>
My answer:
</p>

<p>
(a) &#35813;&#20989;&#25968;&#29992;&#20110;&#21028;&#26029;&#19968;&#20010;&#38750;&#31354;&#30340;list&#20013;&#26159;&#21542;&#21547;&#26377; <b>NIL</b> &#20803;&#32032;.
</p>

<p>
(b) &#21028;&#26029;y&#20013;&#26159;&#21542;&#26377;&#20803;&#32032;&#21644;x&#30456;&#31561;(&#21516;&#19968;&#20010;&#23545;&#35937;)&#65292;&#33509;&#26080;&#21017;&#36820;&#22238;NIL&#65292;&#33509;&#26377;&#21017;&#36820;&#22238;&#35813;&#20803;&#32032;&#22312;y&#20013;&#30340;&#32034;&#24341;(&#20197;0&#20026;&#21021;&#22987;&#20540;).
</p></li>

<li><p>
What could occur in place of the <b>x</b> in each of the following exchanges?
</p>

<pre>
(a) &gt; (car (x (cdr '(a (b c) d))))
    B
(b) &gt; (x 13 (/ 1 0))
    13
(c) &gt; (x #'list 1 nil)
    (1)
</pre>

<p>
My answer:
</p>

<p>
(a) cdr.
</p>

<p>
(b) or.
</p>

<p>
(c) apply.
</p></li>

<li><p>
Using only operators introduced in this Chapter, define a function that takes a list as an argument and returns true if one of its elements is a list.
</p>

<p>
My answer:
</p>
<div>

<pre>(<span>defun</span> <span>have-list-member</span> (lst)
  (<span>if</span> (null lst)
      nil
      (<span>if</span> (listp (car lst))
          t
          (have-list-member (cdr lst)))))
</pre>
</div>

<p>
&#27880;&#65306;&#26412;&#31456;&#20986;&#29616;&#30340;&#25805;&#20316;&#31526;&#26377;&#65306;
</p>
<pre>
+ / - quote list cons car cdr third listp null not if and or defun &gt; eql read format let defparameter defconstant setf remove do dolist progn function apply funcall lambda typep
</pre></li>

<li><p>
Give iterative and recursive definitions of a function that
</p>

<p>
(a) takes a positive integer and prints that many dots.
</p>

<p>
(b) takes a list and returns the number of times the symblo <b>a</b> occurs in it.
</p>

<p>
My answer:
</p>

<p>
(a) dot-plot
</p>

<ul>
<li><p>
Iteractive version
</p>
<div>

<pre>(<span>defun</span> <span>dot-plot-iter</span> (n)
  (<span>do</span> ((n n (- n 1)))
      ((= n 0) 'done)
    (format t <span>"."</span>)))
</pre>
</div></li>
<li><p>
Recursive version
</p>
<div>

<pre>(<span>defun</span> <span>dot-plot-rec</span> (n)
  (<span>if</span> (= n 0)
      'done
      (<span>progn</span>
        (format t <span>"."</span>)
        (dot-plot-rec (- n 1)))))
</pre>
</div></li>
</ul>
<p>
(b) times-of-a
</p>

<ul>
<li><p>
Iteractive version
</p>
<div>

<pre>(<span>defun</span> <span>bfs</span> (lst)                     <span>;&#24191;&#24230;&#20248;&#20808;&#36941;&#21382;&#65292;&#24471;&#21040;lst&#30340;&#25152;&#26377;&#26641;&#21494;&#33410;&#28857;&#30340;&#21015;&#34920;</span>
  (<span>let</span> ((stack (list lst))           <span>;&#36941;&#21382;&#25152;&#38656;&#26632;</span>
        (leaves nil))                <span>;&#23384;&#25918;&#26641;&#21494;&#33410;&#28857;&#30340;&#21015;&#34920;</span>
    (<span>do</span> ()
        ((null stack) leaves)        <span>;&#24403;&#26632;&#31354;&#26102;&#65292;&#36941;&#21382;&#32467;&#26463;</span>
      (<span>let</span> ((now (pop stack)))       <span>;&#23558;&#26632;&#39030;&#33410;&#28857;&#20986;&#26632;</span>
        (<span>if</span> (listp now)              <span>;&#33509;&#20986;&#26632;&#33410;&#28857;&#19981;&#20026;&#26641;&#21494;&#33410;&#28857;&#26102;&#65292;&#23558;&#20854;&#23376;&#26641;&#20837;&#26632;</span>
            (<span>progn</span> (push (car now) stack)
                   (<span>if</span> (not (null (cdr now)))   <span>;&#36825;&#37324;&#35201;&#21028;&#26029;cdr&#26159;&#21542;&#20026;nil&#65292;&#21542;&#21017;&#23558;&#20854;&#20837;&#26632;&#21518;</span>
                       (push (cdr now) stack))) <span>;listp&#23545;&#20854;&#21028;&#26029;&#30340;&#32467;&#26524;&#20026;&#30495;&#65292;&#23548;&#33268;&#26080;&#31351;&#36882;&#24402;</span>
            (push now leaves))))))   <span>;&#33509;&#20986;&#26632;&#33410;&#28857;&#20026;&#26641;&#21494;&#33410;&#28857;&#65292;&#23558;&#20854;&#25918;&#20837;leaves&#21015;&#34920;&#20013;</span>

(<span>defun</span> <span>times-of-a-iter</span> (lst)
  (<span>let</span> ((leaves (bfs lst))
        (times 0))
    (<span>dolist</span> (obj lst)
      (<span>if</span> (equal 'a obj)
          (setf times (+ times 1))))
    times))
</pre>
</div></li>
<li><p>
Recursive version
</p>
<div>

<pre>(<span>defun</span> <span>times-of-a-rec</span> (lst)
  (<span>if</span> (null lst)
       0
      (<span>let</span> ((now (car lst)))
        (+ (<span>if</span> (listp now)
               (times-of-a-rec now)
               (<span>if</span> (equal now 'a) 1 0))
           (times-of-a-rec (cdr lst))))))
</pre>
</div></li>
</ul></li>
</ol>


<ol>
<li><p>
A friend is trying to write a function that returns the sum of all the non-nil elements in a list. He has written two versions of this function, and neither of them work.Explain what's wrong with each, and give a correct version:
</p>

<p>
(a)
</p>
<div>

<pre>(<span>defun</span> <span>summit</span> (lst)
  (remove nil lst)
  (apply #'+ lst))
</pre>
</div>

<p>
(b)
</p>
<div>

<pre>(<span>defun</span> <span>summit</span> (lst)
  (<span>let</span> ((x (car lst)))
    (<span>if</span> (null x)
        (summit (cdr lst))
        (+ x (summit (cdr lst))))))
</pre>
</div>

<p>
My answer:
</p>

<p>
(a) remove&#26159;&#27809;&#26377;&#21103;&#20316;&#29992;(side-effect)&#30340;&#65292;&#25152;&#20197;lst&#20013;&#30340; <b>nil</b> &#20803;&#32032;&#36824;&#22312; lst&#20013;&#65292;&#27491;&#30830;&#30340;&#20195;&#30721;&#24212;&#20026;
</p>
<div>

<pre>(<span>defun</span> <span>summit</span> (lst)
  (apply #&lsquo;+ (remove nil lst)))
</pre>
</div>

<p>
(b) &#27809;&#26377;&#36882;&#24402;&#32456;&#27490;&#26465;&#20214;&#65292;&#27491;&#30830;&#30340;&#20195;&#30721;&#24212;&#20026;&#65306;
</p>
<div>

<pre>(<span>defun</span> <span>summit</span> (lst)
  (<span>if</span> (null lst)
      0
      (<span>let</span> ((x (car lst)))
        (<span>if</span> (null x)
            (summit (cdr lst))
            (+ x (summit (cdr lst)))))))
</pre>
</div></li>
</ol>